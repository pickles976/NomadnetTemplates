#!/usr/bin/env -S csi -s

;;; orm-lib.scm - ORM library for creating and saving model instances
;;;
;;; This provides the runtime functions that users call in their code:
;;;   - make-<model> constructors
;;;   - db-save function

(import scheme)
(import (chicken base))
(import (chicken string))
(import srfi-1)
(import srfi-13)
(import sql-de-lite)

;; ========== INSTANCE REPRESENTATION ==========

;;; An instance is an alist with a special __model__ key:
;;;
;;; '((__model__ . comment)
;;;   (name . "Alice")
;;;   (address . "")
;;;   (text . "Hello"))
;;;
;;; The __model__ key tells us which table to INSERT into

(define (make-instance model-name field-values)
  "Create a new model instance with the given field values"
  ;;;
  ;;; model-name: symbol like 'comment or 'post
  ;;; field-values: alist of field values like '((name . "Alice") (text . "Hi"))
  ;;;
  ;;; Returns an instance (alist with __model__ key)

  (cons `(__model__ . ,model-name) field-values))

(define (instance-model instance)
  "Get the model name from an instance"
  (alist-ref '__model__ instance))

(define (instance-fields instance)
  "Get the field values from an instance (without __model__)"
  ;; Remove the __model__ entry using alist-delete
  (alist-delete '__model__ instance))

;; ========== CONSTRUCTOR GENERATION ==========

;;; We automatically generate make-<model> functions from models.scm
;;; This uses 'eval' and 'quasiquote' to create functions at runtime

(define (generate-constructor model-name)
  "Dynamically create a make-<model> constructor function"
  ;;;
  ;;; For model-name 'comment, this creates:
  ;;;   (define (make-comment fields)
  ;;;     (make-instance 'comment fields))
  ;;;
  ;;; The quasiquote (`) allows us to build code with variable interpolation:
  ;;;   `(define (,func-name ...) ...)
  ;;;
  ;;; The comma (,) means "insert the value of this variable here"

  (let ((constructor-name (string->symbol (conc "make-" (symbol->string model-name)))))
    ;; Uncomment for debugging:
    ;; (print "Generating constructor: " constructor-name)
    (eval `(define (,constructor-name fields)
             (make-instance ',model-name fields)))))

(define (generate-all-constructors)
  "Generate constructor functions for all models"
  ;;;
  ;;; This loads models.scm and creates a make-* function for each model

  ;; Load models - path relative to where scripts are run from (workspace root)
  (load "app/models.scm")

  ;; Generate constructor for each model
  (for-each
    (lambda (model)
      (let ((model-name (alist-ref 'name model)))
        (generate-constructor model-name)))
    all-models))

;; Generate constructors when this library loads
(generate-all-constructors)

;; ========== DATABASE SAVING ==========

(define (find-model model-name all-models)
  "Find a model definition by name"
  ;;;
  ;;; Searches through all-models list for one with matching name
  ;;; Uses 'find' from srfi-1 which returns first matching element or #f

  (find
    (lambda (model)
      (eq? (alist-ref 'name model) model-name))
    all-models))

(define (model-field-names model)
  "Get list of field names (as symbols) from a model, excluding id"
  ;;;
  ;;; We skip 'id' because it's auto-generated by SQLite
  ;;; Returns: (name address page-name timestamp text)

  (let* ((fields (alist-ref 'fields model))
         ;; First filter out the id field
         (non-id-fields
           (filter
             (lambda (field)
               (not (eq? (alist-ref 'name field) 'id)))
             fields)))
    ;; Then map to get just the names
    (map (lambda (field) (alist-ref 'name field)) non-id-fields)))

(define (instance->insert-sql instance model)
  "Generate INSERT SQL for an instance"
  ;;;
  ;;; Generates: INSERT INTO comment (name, address, page_name, text) VALUES (?, ?, ?, ?)
  ;;;
  ;;; We'll convert field names (symbols) to SQL column names (strings with _ instead of -)

  (let* ((table-name (symbol->string (alist-ref 'name model)))
         (field-names (model-field-names model))
         (instance-values (instance-fields instance))

         ;; Convert field names to SQL column names (replace - with _)
         (column-names
           (map (lambda (name)
                  (string-translate (symbol->string name) #\- #\_))
                field-names))

         ;; Create placeholders: "?, ?, ?"
         (placeholders (string-intersperse (make-list (length field-names) "?") ", "))

         ;; Join column names: "name, address, page_name"
         (columns-str (string-intersperse column-names ", ")))

    (conc "INSERT INTO " table-name
          " (" columns-str ")"
          " VALUES (" placeholders ")")))

(define (get-instance-values-in-order instance model)
  "Get instance values in the same order as model fields"
  ;;;
  ;;; This ensures values match the SQL column order
  ;;; Returns a list of values: ("Alice" "" "blog_post" "text")

  (let ((field-names (model-field-names model))
        (instance-values (instance-fields instance)))

    (map
      (lambda (field-name)
        ;; Look up this field in the instance
        (let ((value (alist-ref field-name instance-values)))
          ;; Convert #f to empty string, otherwise keep as-is
          (if value value "")))
      field-names)))

(define db-connection (make-parameter #f))

(define (db-open filename)
  "Open database connection"
  (db-connection (open-database filename)))

(define (db-close)
  "Close database connection"
  (when (db-connection)
    (close-database (db-connection))
    (db-connection #f)))

(define (db-save instance)
  "Save an instance to the database"
  ;;;
  ;;; This generates and executes an INSERT statement
  ;;; Requires: database connection via db-open
  ;;;           models.scm already loaded by generate-all-constructors

  (unless (db-connection)
    (error "No database connection. Call (db-open \"filename.db\") first"))

  ;; Models are already loaded by generate-all-constructors

  (let* ((model-name (instance-model instance))
         (model (find-model model-name all-models))
         (sql-statement (instance->insert-sql instance model))
         (values (get-instance-values-in-order instance model)))

    (print "Saving to database...")
    (print "SQL: " sql-statement)
    (print "Values: " values)

    ;; Execute INSERT with parameter binding
    ;; The 'apply' function spreads the values list as arguments
    (apply exec (sql (db-connection) sql-statement) values)

    (let ((id (last-insert-rowid (db-connection))))
      (print "Saved with ID: " id)
      id)))

;; ========== DATABASE QUERYING ==========

(define (build-select-sql table-name filters)
  "Build SELECT SQL with optional WHERE clause"
  ;;;
  ;;; filters: alist like '((page-name . "blog_post") (name . "Alice"))
  ;;; Returns: "SELECT * FROM table WHERE field = ? AND field = ?"

  (let ((base (conc "SELECT * FROM " table-name)))
    (if (null? filters)
        base
        (let* ((where-parts
                 (map (lambda (filter)
                        (let ((field (string-translate
                                       (symbol->string (car filter))
                                       #\- #\_)))
                          (conc field " = ?")))
                      filters))
               (where-clause (string-intersperse where-parts " AND ")))
          (conc base " WHERE " where-clause)))))

(define (model-all-field-names model)
  "Get ALL field names from a model (including id)"
  ;;;
  ;;; Unlike model-field-names, this includes the id field
  ;;; Returns: (id name address page-name timestamp text)

  (let ((fields (alist-ref 'fields model)))
    (map (lambda (field) (alist-ref 'name field)) fields)))

(define (row->instance model-name field-names row)
  "Convert a database row (list of values) to an instance alist"
  ;;;
  ;;; field-names: (id name address ...)
  ;;; row: (1 "Alice" "" ...)
  ;;; Returns: ((__model__ . comment) (id . 1) (name . "Alice") ...)

  (cons `(__model__ . ,model-name)
        (map cons field-names row)))

(define (db-list model-name . rest)
  "Query database and return list of instances"
  ;;;
  ;;; Usage:
  ;;;   (db-list 'comment)                                ; All comments
  ;;;   (db-list 'comment '((page-name . "blog_post")))  ; Filtered
  ;;;
  ;;; Returns list of instances (alists with __model__ key)

  (unless (db-connection)
    (error "No database connection. Call (db-open \"filename.db\") first"))

  ;; Parse arguments - filters are optional
  (let* ((filters (if (null? rest) '() (car rest)))
         (model (find-model model-name all-models))
         (table-name (symbol->string (alist-ref 'name model)))
         (field-names (model-all-field-names model))

         ;; Build SQL
         (sql-str (build-select-sql table-name filters))
         (stmt (sql (db-connection) sql-str))

         ;; Extract filter values
         (filter-values (map cdr filters))

         ;; Execute query
         (rows (if (null? filter-values)
                   (query fetch-all stmt)
                   (apply query fetch-all stmt filter-values))))

    ;; Convert rows to instances
    (map (lambda (row)
           (row->instance model-name field-names row))
         rows)))

;; ========== LIBRARY LOADED ==========

;; This library is meant to be loaded by other scripts
;; See example-usage.scm for usage examples
